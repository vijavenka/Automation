<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="2.8" jmeter="2.13 r1665067">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <CookieManager guiclass="CookiePanel" testclass="CookieManager" testname="HTTP Cookie Manager" enabled="true">
        <collectionProp name="CookieManager.cookies"/>
        <boolProp name="CookieManager.clearEachIteration">false</boolProp>
      </CookieManager>
      <hashTree/>
      <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
        <collectionProp name="HeaderManager.headers">
          <elementProp name="" elementType="Header">
            <stringProp name="Header.name">content-type</stringProp>
            <stringProp name="Header.value">application/json</stringProp>
          </elementProp>
          <elementProp name="" elementType="Header">
            <stringProp name="Header.name">accept</stringProp>
            <stringProp name="Header.value">application/json</stringProp>
          </elementProp>
          <elementProp name="" elementType="Header">
            <stringProp name="Header.name">accept-encoding</stringProp>
            <stringProp name="Header.value">gzip</stringProp>
          </elementProp>
        </collectionProp>
      </HeaderManager>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="Environment Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="HTTP_PROXY_HOST" elementType="Argument">
            <stringProp name="Argument.name">HTTP_PROXY_HOST</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="HTTP_PROXY_PORT" elementType="Argument">
            <stringProp name="Argument.name">HTTP_PROXY_PORT</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="HTTP_REQUEST_HOST" elementType="Argument">
            <stringProp name="Argument.name">HTTP_REQUEST_HOST</stringProp>
            <stringProp name="Argument.value">test-proxy-qa-01.iatlimited.com</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="HTTP_REQUEST_PORT" elementType="Argument">
            <stringProp name="Argument.name">HTTP_REQUEST_PORT</stringProp>
            <stringProp name="Argument.value">8915</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MYSQL_HOST" elementType="Argument">
            <stringProp name="Argument.name">MYSQL_HOST</stringProp>
            <stringProp name="Argument.value">test-proxy-qa-01.iatlimited.com</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MYSQL_PORT" elementType="Argument">
            <stringProp name="Argument.name">MYSQL_PORT</stringProp>
            <stringProp name="Argument.value">3308</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MYSQL_USERNAME" elementType="Argument">
            <stringProp name="Argument.name">MYSQL_USERNAME</stringProp>
            <stringProp name="Argument.value">admin</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MYSQL_PASSWORD" elementType="Argument">
            <stringProp name="Argument.name">MYSQL_PASSWORD</stringProp>
            <stringProp name="Argument.value">qGZ7zmhsu8Eb</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="counterVariable" elementType="Argument">
            <stringProp name="Argument.name">counterVariable</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="RESPONSE_CODE" elementType="Argument">
            <stringProp name="Argument.name">RESPONSE_CODE</stringProp>
            <stringProp name="Argument.value">200</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="RESPONSE_MESSAGE" elementType="Argument">
            <stringProp name="Argument.name">RESPONSE_MESSAGE</stringProp>
            <stringProp name="Argument.value">OK</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="user" elementType="Argument">
            <stringProp name="Argument.name">user</stringProp>
            <stringProp name="Argument.value">admin_platform</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="password" elementType="Argument">
            <stringProp name="Argument.name">password</stringProp>
            <stringProp name="Argument.value">password</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="periodStartDate" elementType="Argument">
            <stringProp name="Argument.name">periodStartDate</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="periodStartDateMySQL" elementType="Argument">
            <stringProp name="Argument.name">periodStartDateMySQL</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="periodEndDate" elementType="Argument">
            <stringProp name="Argument.name">periodEndDate</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="periodEndDateMySQL" elementType="Argument">
            <stringProp name="Argument.name">periodEndDateMySQL</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="periodRangeDates" elementType="Argument">
            <stringProp name="Argument.name">periodRangeDates</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="newPeriodStartDate" elementType="Argument">
            <stringProp name="Argument.name">newPeriodStartDate</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="newPeriodEndDate" elementType="Argument">
            <stringProp name="Argument.name">newPeriodEndDate</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="numberOfCheckedSubperiods" elementType="Argument">
            <stringProp name="Argument.name">numberOfCheckedSubperiods</stringProp>
            <stringProp name="Argument.value">5</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="MySQL Configuration" enabled="true">
        <boolProp name="autocommit">true</boolProp>
        <stringProp name="checkQuery">Select 1</stringProp>
        <stringProp name="connectionAge">500</stringProp>
        <stringProp name="dataSource">MySQLPM</stringProp>
        <stringProp name="dbUrl">jdbc:mysql://${MYSQL_HOST}:${MYSQL_PORT}/points_manager</stringProp>
        <stringProp name="driver">com.mysql.jdbc.Driver</stringProp>
        <boolProp name="keepAlive">false</boolProp>
        <stringProp name="password">qGZ7zmhsu8Eb</stringProp>
        <stringProp name="poolMax">10</stringProp>
        <stringProp name="timeout">1000</stringProp>
        <stringProp name="transactionIsolation">DEFAULT</stringProp>
        <stringProp name="trimInterval">1000</stringProp>
        <stringProp name="username">${MYSQL_USERNAME}</stringProp>
      </JDBCDataSource>
      <hashTree/>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Epoints reporting API" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">5</stringProp>
        <longProp name="ThreadGroup.start_time">1391682702000</longProp>
        <longProp name="ThreadGroup.end_time">1391682702000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="preconditions" enabled="false"/>
        <hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Log in" enabled="true"/>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Log in" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                <collectionProp name="Arguments.arguments"/>
              </elementProp>
              <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
              <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
              <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
              <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
              <stringProp name="HTTPSampler.protocol">http</stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">api/login?user=admin_platform&amp;password=password</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <boolProp name="HTTPSampler.monitor">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                <collectionProp name="Asserion.test_strings">
                  <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                </collectionProp>
                <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                <boolProp name="Assertion.assume_success">false</boolProp>
                <intProp name="Assertion.test_type">8</intProp>
              </ResponseAssertion>
              <hashTree/>
              <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                <collectionProp name="Asserion.test_strings">
                  <stringProp name="-516244547">${RESPONSE_MESSAGE}</stringProp>
                </collectionProp>
                <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                <boolProp name="Assertion.assume_success">false</boolProp>
                <intProp name="Assertion.test_type">8</intProp>
              </ResponseAssertion>
              <hashTree/>
            </hashTree>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="REPORTING API - return total amount of EPOINTS ISSUED across platform for required date period - (NBO-2418) " enabled="true">
          <stringProp name="TestPlan.comments">REPORTING API - return total amount of EPOINTS ISSUED for UNSUBSCRIBED USERS across platform for required date period - Tests arevery sensitive to set dates, probabyly approach needs to be changed</stringProp>
        </GenericController>
        <hashTree>
          <ModuleController guiclass="ModuleControllerGui" testclass="ModuleController" testname="Login into dashboard, always need to be on" enabled="true">
            <collectionProp name="ModuleController.node_path">
              <stringProp name="-1227702913">WorkBench</stringProp>
              <stringProp name="764597751">Test Plan</stringProp>
              <stringProp name="-590119856">Epoints reporting API</stringProp>
              <stringProp name="1294809499">preconditions</stringProp>
              <stringProp name="-2013538399">Log in</stringProp>
            </collectionProp>
          </ModuleController>
          <hashTree/>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Positive cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - hour" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued  - groupBy hour" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-04-2015 00:00&quot;;
String endDate = &quot;03-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy hour" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, (${counter}+1)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);

	</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - day" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued  - groupBy day" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">day</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;01-05-2015 00:00&quot;;
String endDate = &quot;01-07-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="99228">day</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy day" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy day" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy day" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.DAY_OF_MONTH, (${counter}+1)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - week" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued  - groupBy week" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">week</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper weeks ranges
String startDate = &quot;30-03-2015 00:00&quot;;
String endDate = &quot;27-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3645428">week</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, (i*7)); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy week" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy week" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy week" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, (${counter}*7)); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.DAY_OF_MONTH, ((${counter}+1)*7)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - month" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued  - groupBy month" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">month</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper months ranges
String startDate = &quot;01-07-2014 00:00&quot;;
String endDate = &quot;01-09-2014 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="104080000">month</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	//roznica jednego dnia
	cal.add(Calendar.MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy month" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy month" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.MONTH, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.MONTH, ${counter}+1); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - year" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued  - groupBy year" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">year</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper year ranges
String startDate = &quot;1-01-2005 00:00&quot;;
String endDate = &quot;01-01-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="post data" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="293428022">groupBy</stringProp>
                    <stringProp name="-261425617">dateRange</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="-2110402742">
                      <stringProp name="99228">day</stringProp>
                      <stringProp name="1733077901">02-04-2015+00:00+%2B0000,03-04-2015+00:00+%2B0000</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3704893">year</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.YEAR, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy year" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy year" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy year" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.YEAR, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.YEAR, ${counter}+1); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="previousPeriod - false" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued  - groupBy hour" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">false</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-04-2015 00:00&quot;;
String endDate = &quot;03-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: previousTotalCount" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3392903">null</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">previousTotalCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - hour, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued, groupBy - hour, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;169&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 169, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy hour" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));

	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, (${counter})); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, ((${counter}+1))); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	if(${counter} == 0){
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}else if(${counter} == 168){
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - day, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued, groupBy - day, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">day</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="99228">day</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;8&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 8, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy day" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy day" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">1000</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy day" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));

	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, (24*${counter})); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, (24*(${counter}+1))); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	if(${counter} == 0){
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}else if(${counter} == 7){
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - week, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued, groupBy - week, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">week</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3645428">week</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 2, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(i==0){
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}else if(i!=0){
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		cal.add(Calendar.DAY_OF_MONTH, (i*7)); 
		tempCalculatedDate =  cal.getTime(); 
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy week" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy week" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy week" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

	if(${counter} == 0){
		Calendar cal = Calendar.getInstance();
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));

		cal.add(Calendar.DAY_OF_MONTH, 7); 
		tempCalculatedDateTo =  cal.getTime(); 
		String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
		
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
		
	}else if(${counter} == 1){
		Calendar cal = Calendar.getInstance();
		cal.setTime(tempApiEnd); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		tempCalculatedDateFrom =  cal.getTime(); 
		String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
		
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);	
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - month, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued, groupBy - month, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">month</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="104080000">month</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(  vars.get(&quot;itemCount&quot;).equals(&quot;1&quot;) || vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 1 or 2 occording of current date, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(i==0){
			cal.setTime(tempApiStart); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}else if(i!=0){
			cal.setTime(tempApiEnd); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}
	}else{
		cal.setTime(tempApiStart); 
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy month" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy month" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(${counter} == 0){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiStart); 
			
			vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
	
			cal.add(Calendar.MONTH, 1); 
			tempCalculatedDateTo =  cal.getTime(); 
			String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
			
			vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
			
		}else if(${counter} == 1){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiEnd); 
			tempCalculatedDateFrom =  cal.getTime(); 
			String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
			
			vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);	
			vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
		}
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - year, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued, groupBy - year, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">year</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1743861035">points-issued</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1686520632">Issued points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3704893">year</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(  vars.get(&quot;itemCount&quot;).equals(&quot;1&quot;) || vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 1 or 2 occording of current date, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(i==0){
			cal.setTime(tempApiStart); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}else if(i!=0){
			cal.setTime(tempApiEnd); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}
	}else{
		cal.setTime(tempApiStart); 
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy year" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy year" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(${counter} == 0){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiStart); 
			
			vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
	
			cal.add(Calendar.YEAR, 1); 
			tempCalculatedDateTo =  cal.getTime(); 
			String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
			
			vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
			
		}else if(${counter} == 1){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiEnd); 
			tempCalculatedDateFrom =  cal.getTime(); 
			String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
			
			vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);		
			vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
		}
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Negative cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong groubBy" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong dateRange" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong previousPeriod" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="REPORTING API - return total amount of EPOINTS CONFIRMED across platform for required date period - (NBO-2421) " enabled="true">
          <stringProp name="TestPlan.comments">REPORTING API - return total amount of EPOINTS CONFIRMED across platform for required date period - Tests arevery sensitive to set dates, probabyly approach needs to be changed</stringProp>
        </GenericController>
        <hashTree>
          <ModuleController guiclass="ModuleControllerGui" testclass="ModuleController" testname="Login into dashboard, always need to be on" enabled="true">
            <collectionProp name="ModuleController.node_path">
              <stringProp name="-1227702913">WorkBench</stringProp>
              <stringProp name="764597751">Test Plan</stringProp>
              <stringProp name="-590119856">Epoints reporting API</stringProp>
              <stringProp name="1294809499">preconditions</stringProp>
              <stringProp name="-2013538399">Log in</stringProp>
            </collectionProp>
          </ModuleController>
          <hashTree/>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Positive cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - hour" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points confirmed  - groupBy hour" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-04-2015 00:00&quot;;
String endDate = &quot;03-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy hour" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, (${counter}+1)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);

	</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - day" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points confirmed  - groupBy day" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">day</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;01-05-2015 00:00&quot;;
String endDate = &quot;01-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="99228">day</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy day" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy day" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy day" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.DAY_OF_MONTH, (${counter}+1)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - week" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points confirmed  - groupBy week" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">week</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper weeks ranges
String startDate = &quot;30-03-2015 00:00&quot;;
String endDate = &quot;27-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3645428">week</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, (i*7)); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy week" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy week" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy week" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, (${counter}*7)); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.DAY_OF_MONTH, ((${counter}+1)*7)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - month" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points confirmed  - groupBy month" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">month</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper months ranges
String startDate = &quot;01-07-2014 00:00&quot;;
String endDate = &quot;01-09-2014 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="104080000">month</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	//roznica jednego dnia
	cal.add(Calendar.MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy month" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy month" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.MONTH, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.MONTH, ${counter}+1); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - year" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points confirmed  - groupBy year" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">year</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper year ranges
String startDate = &quot;01-01-2005 00:00&quot;;
String endDate = &quot;01-01-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="post data" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="293428022">groupBy</stringProp>
                    <stringProp name="-261425617">dateRange</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="-2110402742">
                      <stringProp name="99228">day</stringProp>
                      <stringProp name="1733077901">02-04-2015+00:00+%2B0000,03-04-2015+00:00+%2B0000</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3704893">year</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.YEAR, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy year" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy year" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy year" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.YEAR, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.YEAR, ${counter}+1); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="previousPeriod - false" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points issued  - groupBy hour" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">false</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-04-2015 00:00&quot;;
String endDate = &quot;03-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: previousTotalCount" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3392903">null</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">previousTotalCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - hour, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points confirmed, groupBy - hour, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;169&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 169, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy hour" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));

	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, (${counter})); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, ((${counter}+1))); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	if(${counter} == 0){
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}else if(${counter} == 168){
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - day, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points confirmed, groupBy - day, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">day</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="99228">day</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;8&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 8, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy day" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy day" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy day" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));

	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, (24*${counter})); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, (24*(${counter}+1))); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	if(${counter} == 0){
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}else if(${counter} == 7){
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - week, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points confirmed, groupBy - week, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">week</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3645428">week</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 2, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(i==0){
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}else if(i!=0){
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		cal.add(Calendar.DAY_OF_MONTH, (i*7)); 
		tempCalculatedDate =  cal.getTime(); 
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy week" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy week" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy week" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

	if(${counter} == 0){
		Calendar cal = Calendar.getInstance();
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));

		cal.add(Calendar.DAY_OF_MONTH, 7); 
		tempCalculatedDateTo =  cal.getTime(); 
		String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
		
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
		
	}else if(${counter} == 1){
		Calendar cal = Calendar.getInstance();
		cal.setTime(tempApiEnd); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		tempCalculatedDateFrom =  cal.getTime(); 
		String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
		
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);	
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - month, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points confirmed, groupBy - week, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">month</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="104080000">month</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(  vars.get(&quot;itemCount&quot;).equals(&quot;1&quot;) || vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 1 or 2 occording of current date, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(i==0){
			cal.setTime(tempApiStart); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}else if(i!=0){
		cal.setTime(tempApiEnd); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}
	}else{
		cal.setTime(tempApiStart); 
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy month" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy month" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(${counter} == 0){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiStart); 
			
			vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
	
			cal.add(Calendar.MONTH, 1); 
			tempCalculatedDateTo =  cal.getTime(); 
			String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
			
			vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
			
		}else if(${counter} == 1){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiEnd); 
			tempCalculatedDateFrom =  cal.getTime(); 
			String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
			
			vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);	
			vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
		}
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - year, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points confirmed, groupBy - year, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">year</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3704893">year</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(  vars.get(&quot;itemCount&quot;).equals(&quot;1&quot;) || vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 1 or 2 occording of current date, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(i==0){
			cal.setTime(tempApiStart); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}else if(i!=0){
			cal.setTime(tempApiEnd); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}
	}else{
		cal.setTime(tempApiStart); 
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy year" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy year" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(${counter} == 0){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiStart); 
			
			vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
	
			cal.add(Calendar.YEAR, 1); 
			tempCalculatedDateTo =  cal.getTime(); 
			String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
			
			vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
			
		}else if(${counter} == 1){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiEnd); 
			tempCalculatedDateFrom =  cal.getTime(); 
			String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
			
			vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);		
			vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
		}
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Negative cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong groubBy" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong dateRange" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong previousPeriod" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="REPORTING API - return total amount of EPOINTS PENDING across platform for required date period  - (NBO-2425) " enabled="true">
          <stringProp name="TestPlan.comments">REPORTING API - return total amount of EPOINTS PENDING across platform for required date period  - Tests arevery sensitive to set dates, probabyly approach needs to be changed</stringProp>
        </GenericController>
        <hashTree>
          <ModuleController guiclass="ModuleControllerGui" testclass="ModuleController" testname="Login into dashboard, always need to be on" enabled="true">
            <collectionProp name="ModuleController.node_path">
              <stringProp name="-1227702913">WorkBench</stringProp>
              <stringProp name="764597751">Test Plan</stringProp>
              <stringProp name="-590119856">Epoints reporting API</stringProp>
              <stringProp name="1294809499">preconditions</stringProp>
              <stringProp name="-2013538399">Log in</stringProp>
            </collectionProp>
          </ModuleController>
          <hashTree/>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Positive cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - hour" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending  - groupBy hour" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-04-2015 00:00&quot;;
String endDate = &quot;03-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy hour" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, (${counter}+1)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);

	</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - day" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending  - groupBy day" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">day</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;01-05-2015 00:00&quot;;
String endDate = &quot;01-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="99228">day</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy day" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy day" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy day" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.DAY_OF_MONTH, (${counter}+1)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - week" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending  - groupBy week" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">week</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper weeks ranges
String startDate = &quot;30-03-2015 00:00&quot;;
String endDate = &quot;27-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3645428">week</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, (i*7)); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy week" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy week" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy week" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, (${counter}*7)); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.DAY_OF_MONTH, ((${counter}+1)*7)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - month" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending  - groupBy month" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">month</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper months ranges
String startDate = &quot;01-07-2014 00:00&quot;;
String endDate = &quot;01-09-2014 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="104080000">month</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	//roznica jednego dnia
	cal.add(Calendar.MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy month" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy month" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.MONTH, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.MONTH, ${counter}+1); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - year" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending - groupBy year" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">year</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper year ranges
String startDate = &quot;01-01-2005 00:00&quot;;
String endDate = &quot;01-01-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="post data" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="293428022">groupBy</stringProp>
                    <stringProp name="-261425617">dateRange</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="-2110402742">
                      <stringProp name="99228">day</stringProp>
                      <stringProp name="1733077901">02-04-2015+00:00+%2B0000,03-04-2015+00:00+%2B0000</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3704893">year</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.YEAR, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy year" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy year" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy year" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.YEAR, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.YEAR, ${counter}+1); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="previousPeriod - false" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending  - groupBy hour" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">false</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-04-2015 00:00&quot;;
String endDate = &quot;03-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: previousTotalCount" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3392903">null</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">previousTotalCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - hour, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending, groupBy - hour, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;169&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 169, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy hour" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));

	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, (${counter})); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, ((${counter}+1))); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	if(${counter} == 0){
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}else if(${counter} == 168){
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - day, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending, groupBy - day, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">day</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="99228">day</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;8&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 8, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy day" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy day" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy day" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));

	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, (24*${counter})); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, (24*(${counter}+1))); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	if(${counter} == 0){
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}else if(${counter} == 7){
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - week, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending, groupBy - week, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">week</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3645428">week</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 2, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(i==0){
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}else if(i!=0){
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		cal.add(Calendar.DAY_OF_MONTH, (i*7)); 
		tempCalculatedDate =  cal.getTime(); 
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy week" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy week" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy week" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

	if(${counter} == 0){
		Calendar cal = Calendar.getInstance();
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));

		cal.add(Calendar.DAY_OF_MONTH, 7); 
		tempCalculatedDateTo =  cal.getTime(); 
		String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
		
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
		
	}else if(${counter} == 1){
		Calendar cal = Calendar.getInstance();
		cal.setTime(tempApiEnd); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		tempCalculatedDateFrom =  cal.getTime(); 
		String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
		
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);	
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - month, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending, groupBy - week, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">month</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="104080000">month</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(  vars.get(&quot;itemCount&quot;).equals(&quot;1&quot;) || vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 1 or 2 occording of current date, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(i==0){
			cal.setTime(tempApiStart); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}else if(i!=0){
		cal.setTime(tempApiEnd); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}
	}else{
		cal.setTime(tempApiStart); 
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy month" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy month" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(${counter} == 0){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiStart); 
			
			vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
	
			cal.add(Calendar.MONTH, 1); 
			tempCalculatedDateTo =  cal.getTime(); 
			String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
			
			vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
			
		}else if(${counter} == 1){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiEnd); 
			tempCalculatedDateFrom =  cal.getTime(); 
			String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
			
			vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);	
			vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
		}
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - year, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points pending, groupBy - year, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">year</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1008453971">points-pending</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1194091108">Pending points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3704893">year</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(  vars.get(&quot;itemCount&quot;).equals(&quot;1&quot;) || vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 1 or 2 occording of current date, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(i==0){
			cal.setTime(tempApiStart); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}else if(i!=0){
			cal.setTime(tempApiEnd); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}
	}else{
		cal.setTime(tempApiStart); 
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy year" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy year" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;PENDING&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(${counter} == 0){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiStart); 
			
			vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
	
			cal.add(Calendar.YEAR, 1); 
			tempCalculatedDateTo =  cal.getTime(); 
			String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
			
			vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
			
		}else if(${counter} == 1){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiEnd); 
			tempCalculatedDateFrom =  cal.getTime(); 
			String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
			
			vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);		
			vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
		}
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Negative cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong groubBy" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-pending" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong dateRange" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-pending" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong previousPeriod" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-pending" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-pending</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="REPORTING API - return total amount of EPOINTS REDEEMED across platform for required date period  - (NBO-2434) " enabled="true">
          <stringProp name="TestPlan.comments">REPORTING API - return total amount of EPOINTS REDEEMED across platform for required date period - Tests arevery sensitive to set dates, probabyly approach needs to be changed</stringProp>
        </GenericController>
        <hashTree>
          <ModuleController guiclass="ModuleControllerGui" testclass="ModuleController" testname="Login into dashboard, always need to be on" enabled="true">
            <collectionProp name="ModuleController.node_path">
              <stringProp name="-1227702913">WorkBench</stringProp>
              <stringProp name="764597751">Test Plan</stringProp>
              <stringProp name="-590119856">Epoints reporting API</stringProp>
              <stringProp name="1294809499">preconditions</stringProp>
              <stringProp name="-2013538399">Log in</stringProp>
            </collectionProp>
          </ModuleController>
          <hashTree/>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Positive cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - hour" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed  - groupBy hour" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-04-2015 00:00&quot;;
String endDate = &quot;03-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy hour" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, (${counter}+1)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);

	</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - day" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed  - groupBy day" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">day</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;01-05-2015 00:00&quot;;
String endDate = &quot;01-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="99228">day</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy day" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy day" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy day" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.DAY_OF_MONTH, (${counter}+1)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - week" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed  - groupBy week" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">week</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper weeks ranges
String startDate = &quot;30-03-2015 00:00&quot;;
String endDate = &quot;27-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3645428">week</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, (i*7)); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy week" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy week" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy week" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, (${counter}*7)); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.DAY_OF_MONTH, ((${counter}+1)*7)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - month" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed  - groupBy month" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">month</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper months ranges
String startDate = &quot;01-07-2014 00:00&quot;;
String endDate = &quot;01-09-2014 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="104080000">month</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	//roznica jednego dnia
	cal.add(Calendar.MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy month" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy month" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.MONTH, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.MONTH, ${counter}+1); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - year" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed - groupBy year" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">year</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper year ranges
String startDate = &quot;01-01-2005 00:00&quot;;
String endDate = &quot;01-01-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="post data" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="293428022">groupBy</stringProp>
                    <stringProp name="-261425617">dateRange</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="-2110402742">
                      <stringProp name="99228">day</stringProp>
                      <stringProp name="1733077901">02-04-2015+00:00+%2B0000,03-04-2015+00:00+%2B0000</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3704893">year</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.YEAR, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy year" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy year" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy year" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.YEAR, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.YEAR, ${counter}+1); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="previousPeriod - false" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed  - groupBy hour" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">false</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-04-2015 00:00&quot;;
String endDate = &quot;03-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: previousTotalCount" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3392903">null</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">previousTotalCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - hour, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed, groupBy - hour, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;169&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 169, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy hour" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));

	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, (${counter})); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, ((${counter}+1))); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	if(${counter} == 0){
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}else if(${counter} == 168){
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - day, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed, groupBy - day, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">day</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="99228">day</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;8&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 8, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy day" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy day" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy day" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));

	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, (24*${counter})); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, (24*(${counter}+1))); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	if(${counter} == 0){
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}else if(${counter} == 7){
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - week, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed, groupBy - week, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">week</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3645428">week</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 2, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(i==0){
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}else if(i!=0){
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		cal.add(Calendar.DAY_OF_MONTH, (i*7)); 
		tempCalculatedDate =  cal.getTime(); 
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy week" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy week" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy week" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

	if(${counter} == 0){
		Calendar cal = Calendar.getInstance();
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));

		cal.add(Calendar.DAY_OF_MONTH, 7); 
		tempCalculatedDateTo =  cal.getTime(); 
		String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
		
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
		
	}else if(${counter} == 1){
		Calendar cal = Calendar.getInstance();
		cal.setTime(tempApiEnd); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		tempCalculatedDateFrom =  cal.getTime(); 
		String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
		
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);	
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - month, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed, groupBy - week, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">month</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="104080000">month</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(  vars.get(&quot;itemCount&quot;).equals(&quot;1&quot;) || vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 1 or 2 occording of current date, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(i==0){
			cal.setTime(tempApiStart); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}else if(i!=0){
		cal.setTime(tempApiEnd); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}
	}else{
		cal.setTime(tempApiStart); 
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy month" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy month" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(${counter} == 0){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiStart); 
			
			vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
	
			cal.add(Calendar.MONTH, 1); 
			tempCalculatedDateTo =  cal.getTime(); 
			String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
			
			vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
			
		}else if(${counter} == 1){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiEnd); 
			tempCalculatedDateFrom =  cal.getTime(); 
			String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
			
			vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);	
			vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
		}
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - year, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points redeemed, groupBy - year, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">year</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2002830565">points-redeemed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1333632456">Redeemed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3704893">year</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(  vars.get(&quot;itemCount&quot;).equals(&quot;1&quot;) || vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 1 or 2 occording of current date, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(i==0){
			cal.setTime(tempApiStart); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}else if(i!=0){
			cal.setTime(tempApiEnd); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}
	}else{
		cal.setTime(tempApiStart); 
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy year" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy year" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;REDEEMED&apos;) AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(${counter} == 0){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiStart); 
			
			vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
	
			cal.add(Calendar.YEAR, 1); 
			tempCalculatedDateTo =  cal.getTime(); 
			String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
			
			vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
			
		}else if(${counter} == 1){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiEnd); 
			tempCalculatedDateFrom =  cal.getTime(); 
			String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
			
			vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);		
			vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
		}
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Negative cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong groubBy" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-redeemed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong dateRange" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-redeemed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong previousPeriod" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-redeemed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-redeemed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="REPORTING API - return total amount of EPOINTS ISSUED for UNSUBSCRIBED USERS across platform for required date period  - (NBO-2429) " enabled="true">
          <stringProp name="TestPlan.comments">REPORTING API - return total amount of EPOINTS REDEEMED across platform for required date period - Tests arevery sensitive to set dates, probabyly approach needs to be changed</stringProp>
        </GenericController>
        <hashTree>
          <ModuleController guiclass="ModuleControllerGui" testclass="ModuleController" testname="Login into dashboard, always need to be on" enabled="true">
            <collectionProp name="ModuleController.node_path">
              <stringProp name="-1227702913">WorkBench</stringProp>
              <stringProp name="764597751">Test Plan</stringProp>
              <stringProp name="-590119856">Epoints reporting API</stringProp>
              <stringProp name="1294809499">preconditions</stringProp>
              <stringProp name="-2013538399">Log in</stringProp>
            </collectionProp>
          </ModuleController>
          <hashTree/>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Positive cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - hour" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed - groupBy hour" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-04-2015 00:00&quot;;
String endDate = &quot;03-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy hour" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, (${counter}+1)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);

	</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - day" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed  - groupBy day" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">day</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;01-05-2015 00:00&quot;;
String endDate = &quot;01-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="99228">day</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy day" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy day" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy day" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.DAY_OF_MONTH, (${counter}+1)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - week" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed  - groupBy week" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">week</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper weeks ranges
String startDate = &quot;30-03-2015 00:00&quot;;
String endDate = &quot;27-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3645428">week</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, (i*7)); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy week" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy week" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy week" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, (${counter}*7)); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.DAY_OF_MONTH, ((${counter}+1)*7)); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - month" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed  - groupBy month" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">month</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper months ranges
String startDate = &quot;01-07-2014 00:00&quot;;
String endDate = &quot;01-09-2014 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="104080000">month</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	//roznica jednego dnia
	cal.add(Calendar.MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy month" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy month" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.MONTH, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.MONTH, ${counter}+1); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - year" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed - groupBy year" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">year</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

//for weeks we need to have proper year ranges
String startDate = &quot;01-01-2005 00:00&quot;;
String endDate = &quot;01-01-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="post data" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="293428022">groupBy</stringProp>
                    <stringProp name="-261425617">dateRange</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="-2110402742">
                      <stringProp name="99228">day</stringProp>
                      <stringProp name="1733077901">02-04-2015+00:00+%2B0000,03-04-2015+00:00+%2B0000</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3704893">year</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.YEAR, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy year" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result -  &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy year" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy year" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.YEAR, ${counter}); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.YEAR, ${counter}+1); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
	vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="previousPeriod - false" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed  - groupBy hour" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">false</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-04-2015 00:00&quot;;
String endDate = &quot;03-04-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: previousTotalCount" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3392903">null</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">previousTotalCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - hour, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed, groupBy - hour, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3208676">hour</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;169&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 169, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy hour" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));

	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, (${counter})); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, ((${counter}+1))); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	if(${counter} == 0){
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}else if(${counter} == 168){
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - day, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed, groupBy - day, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">day</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="99228">day</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;8&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 8, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){
	
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.DAY_OF_MONTH, i); 
	Date tempCalculatedDate =  cal.getTime(); 
	Long tempCalculatedTimestamp = tempCalculatedDate.getTime();

	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy day" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy day" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy day" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));

	Calendar cal = Calendar.getInstance();
	cal.setTime(tempApiStart); 
	cal.add(Calendar.HOUR_OF_DAY, (24*${counter})); 
	Date tempNewDateFrom =  cal.getTime(); 
	String tempNewDateFromMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 

	Calendar cal2 = Calendar.getInstance();
	cal2.setTime(tempApiStart); 
	cal2.add(Calendar.HOUR_OF_DAY, (24*(${counter}+1))); 
	Date tempNewDateTo =  cal2.getTime(); 
	String tempNewDateToMySQLFormat = mySQLFormat.format(tempNewDateTo).toString(); 

	if(${counter} == 0){
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}else if(${counter} == 7){
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - week, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed, groupBy - week, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">week</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3645428">week</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 2, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(i==0){
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}else if(i!=0){
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		cal.add(Calendar.DAY_OF_MONTH, (i*7)); 
		tempCalculatedDate =  cal.getTime(); 
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy week" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy week" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy week" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

	if(${counter} == 0){
		Calendar cal = Calendar.getInstance();
		cal.setTime(tempApiStart); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));

		cal.add(Calendar.DAY_OF_MONTH, 7); 
		tempCalculatedDateTo =  cal.getTime(); 
		String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
		
		vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
		
	}else if(${counter} == 1){
		Calendar cal = Calendar.getInstance();
		cal.setTime(tempApiEnd); 
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK) - cal.getFirstDayOfWeek();
		cal.add(Calendar.DAY_OF_MONTH, -dayOfWeek);
		tempCalculatedDateFrom =  cal.getTime(); 
		String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
		
		vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);	
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - month, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed, groupBy - week, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">month</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="104080000">month</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(  vars.get(&quot;itemCount&quot;).equals(&quot;1&quot;) || vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 1 or 2 occording of current date, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(i==0){
			cal.setTime(tempApiStart); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}else if(i!=0){
		cal.setTime(tempApiEnd); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}
	}else{
		cal.setTime(tempApiStart); 
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy month" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy month" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;MM-yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(${counter} == 0){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiStart); 
			
			vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
	
			cal.add(Calendar.MONTH, 1); 
			tempCalculatedDateTo =  cal.getTime(); 
			String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
			
			vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
			
		}else if(${counter} == 1){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiEnd); 
			tempCalculatedDateFrom =  cal.getTime(); 
			String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
			
			vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);	
			vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
		}
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - year, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed, groupBy - year, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">year</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;yyyy&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);

String endDatePeriodFormat = apiFormatForPeriods.format(now).toString(); 
vars.put(&quot;periodEndDate&quot;, endDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-2145678421">points-issued-unsubscribed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="113190970">Points issued for unsubscribed users details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3704893">year</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3076014">date</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;key&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: label" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">label</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;label&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(  vars.get(&quot;itemCount&quot;).equals(&quot;1&quot;) || vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements should be 1 or 2 occording of current date, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: check each key values and label correctness" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;yyyy&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

for(int i=0;i&lt;(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-3);i++){

	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	Calendar cal = Calendar.getInstance();
	Date tempCalculatedDate;
	Long tempCalculatedTimestamp;
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(i==0){
			cal.setTime(tempApiStart); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}else if(i!=0){
			cal.setTime(tempApiEnd); 
			tempCalculatedDate =  cal.getTime();
			tempCalculatedTimestamp = tempCalculatedDate.getTime();
		}
	}else{
		cal.setTime(tempApiStart); 
		tempCalculatedDate =  cal.getTime();
		tempCalculatedTimestamp = tempCalculatedDate.getTime();
	}


	if(   vars.get(&quot;key_&quot;+(i+1)).equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; value is incorrect. API value - &quot;+vars.get(&quot;key_&quot;+(i+1))+&quot;, date counted value - &quot;+tempCalculatedTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	Date tempApiReturnedLabelDate = apiFormatReturned.parse(vars.get(&quot;label_&quot;+(i+1)));
	Long tempApiReturnedLabelTimestamp = tempApiReturnedLabelDate.getTime() ;

	if(   tempApiReturnedLabelTimestamp.toString().equals(tempCalculatedTimestamp.toString())   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Period &quot;+i+&quot; label is incorrect. Date counted value and converted to epoch - &quot;+tempCalculatedTimestamp.toString()+&quot;, label converted to epoch value - &quot;+tempApiReturnedLabelTimestamp.toString();
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy year" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy month" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points WHERE Points.status in (&apos;CONFIRMED&apos;, &apos;PENDING&apos;, &apos;REDEEMED&apos;) AND tagId != &apos;47&apos; AND  createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach period interval check correctness of points value" enabled="true">
                <stringProp name="ForeachController.inputVal">value</stringProp>
                <stringProp name="ForeachController.returnVal">loopValue</stringProp>
                <boolProp name="ForeachController.useSeparator">true</boolProp>
                <stringProp name="ForeachController.endIndex">${numberOfCheckedSubperiods}</stringProp>
              </ForeachController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="counter" enabled="true">
                  <stringProp name="CounterConfig.start">0</stringProp>
                  <stringProp name="CounterConfig.end">${numberOfCheckedSubperiods}</stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">counter</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get epoints count of selected period from MySQL and check if it is correct according to api  - groupBy year" enabled="true">
                  <stringProp name="dataSource">MySQLPM</stringProp>
                  <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;REDEEMED&apos;,&apos;PENDING&apos;,&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${newPeriodEndDate}&apos; AND u.active = false AND p.tagId != &apos;47&apos;;</stringProp>
                  <stringProp name="queryArguments"></stringProp>
                  <stringProp name="queryArgumentsTypes"></stringProp>
                  <stringProp name="queryTimeout"></stringProp>
                  <stringProp name="queryType">Select Statement</stringProp>
                  <stringProp name="resultVariable"></stringProp>
                  <stringProp name="variableNames">periodCountDB</stringProp>
                  <stringProp name="resultSetHandler">Store as String</stringProp>
                </JDBCSampler>
                <hashTree>
                  <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                    <boolProp name="resetInterpreter">false</boolProp>
                    <stringProp name="parameters"></stringProp>
                    <stringProp name="filename"></stringProp>
                    <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

	SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;yyyy&quot;);
	SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
	Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
	Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));
	if(vars.get(&quot;itemCount&quot;).equals(&quot;2&quot;)){
		if(${counter} == 0){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiStart); 
			
			vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
	
			cal.add(Calendar.YEAR, 1); 
			tempCalculatedDateTo =  cal.getTime(); 
			String tempNewDateToMySQLFormat = mySQLFormat.format(tempCalculatedDateTo).toString(); 
			
			vars.put(&quot;newPeriodEndDate&quot;, tempNewDateToMySQLFormat);
			
		}else if(${counter} == 1){
			Calendar cal = Calendar.getInstance();
			cal.setTime(tempApiEnd); 
			tempCalculatedDateFrom =  cal.getTime(); 
			String tempNewDateFromMySQLFormat = mySQLFormat.format(tempCalculatedDateFrom).toString(); 
			
			vars.put(&quot;newPeriodStartDate&quot;, tempNewDateFromMySQLFormat);		
			vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
		}
	}else{
		vars.put(&quot;newPeriodStartDate&quot;, vars.get(&quot;periodStartDateMySQL&quot;));
		vars.put(&quot;newPeriodEndDate&quot;, vars.get(&quot;periodEndDateMySQL&quot;));
	}</stringProp>
                  </BeanShellPreProcessor>
                  <hashTree/>
                  <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                    <collectionProp name="Asserion.test_strings">
                      <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                    </collectionProp>
                    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                    <boolProp name="Assertion.assume_success">false</boolProp>
                    <intProp name="Assertion.test_type">8</intProp>
                    <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                  </ResponseAssertion>
                  <hashTree/>
                  <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                    <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                    <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;periodCountDB_1&quot;) == null){
	if(   vars.get(&quot;loopValue&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for period &quot;+${counter}+&quot; ,api should returns 0 points but returned - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
		if(   vars.get(&quot;periodCountDB_1&quot;).equals(vars.get(&quot;loopValue&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong value of points count for period &quot;+${counter}+&quot; , database points value - &quot;+vars.get(&quot;periodCountDB_1&quot;)+&quot;, api returned points value - &quot;+vars.get(&quot;loopValue&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                    <stringProp name="BeanShellAssertion.filename"></stringProp>
                    <stringProp name="BeanShellAssertion.parameters"></stringProp>
                    <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                  </BeanShellAssertion>
                  <hashTree/>
                </hashTree>
              </hashTree>
            </hashTree>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Negative cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong groubBy" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong dateRange" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong previousPeriod" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="REPORTING API - show breakdown of CONFIRMED points by user for required date range - (NBO-2424) " enabled="true">
          <stringProp name="TestPlan.comments">REPORTING API - return total amount of EPOINTS REDEEMED across platform for required date period - Tests arevery sensitive to set dates, probabyly approach needs to be changed</stringProp>
        </GenericController>
        <hashTree>
          <ModuleController guiclass="ModuleControllerGui" testclass="ModuleController" testname="Login into dashboard, always need to be on" enabled="true">
            <collectionProp name="ModuleController.node_path">
              <stringProp name="-1227702913">WorkBench</stringProp>
              <stringProp name="764597751">Test Plan</stringProp>
              <stringProp name="-590119856">Epoints reporting API</stringProp>
              <stringProp name="1294809499">preconditions</stringProp>
              <stringProp name="-2013538399">Log in</stringProp>
            </collectionProp>
          </ModuleController>
          <hashTree/>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Positive cases" enabled="true"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - user" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed - groupBy user" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">user</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-02-2015 00:00&quot;;
String endDate = &quot;03-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3599307">user</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1178503868">headerDefined</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;userKey&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: email" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">email</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;email&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: totalCount default value == 10" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1567">10</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">itemCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Check correctness of each user key,email and points value, check default sort order and default orderBy" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT u.userKey, u.email, SUM(delta) as suma FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; GROUP by userId order by suma DESC;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">userKey,userEmail,pointsValue</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: of each user key,email and points value" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">for(int i=1;i&lt;=(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-1);i++){

	//same values are ordered in different way by api and jmeter queries that wy we do not process them
     if(vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i+1))) || vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i-1)))){
     	print(&quot;continue - &quot; +i);
     	continue;
     }else {     	
		print(vars.get(&quot;userKey_&quot;+i) + &quot;  -  &quot; + i);
		print(vars.get(&quot;key_&quot;+i) + &quot;  -  &quot; + i);
     }
	
	if(   vars.get(&quot;userKey_&quot;+i).equals(vars.get(&quot;key_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user keys on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;key_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;userKey_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;userEmail_&quot;+i).equals(vars.get(&quot;email_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user emails on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;userEmail_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;email_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;pointsValue_&quot;+i).equals(vars.get(&quot;value_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user points values on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;pointsValue_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;value_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="previousPeriod - false" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed - groupBy user" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">user</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">false</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-02-2015 00:00&quot;;
String endDate = &quot;03-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: previousTotalCount" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3392903">null</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">previousTotalCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3599307">user</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1178503868">headerDefined</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;userKey&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: email" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">email</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;email&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: totalCount default value == 10" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1567">10</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">itemCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - user, no dateRange, should be last 7 days" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed - groupBy - user, no dateRange, should be last 7 days" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">user</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

Date now = new Date( );

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
SimpleDateFormat apiFormatForPeriods  = new SimpleDateFormat(&quot;dd-MM-yyyy HH&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatForPeriods.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Calendar cal = Calendar.getInstance();
cal.setTime(now); 
cal.add(Calendar.HOUR_OF_DAY, -168); 
Date tempNewDateFrom =  cal.getTime(); 

String startDateMySQLFormat = mySQLFormat.format(tempNewDateFrom).toString(); 
String endDateMySQLFormat = mySQLFormat.format(now).toString();
vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);

String startDatePeriodFormat = apiFormatForPeriods.format(tempNewDateFrom).toString(); 
vars.put(&quot;periodStartDate&quot;, startDatePeriodFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3599307">user</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1178503868">headerDefined</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;userKey&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: email" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">email</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;email&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: totalCount default value == 10" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1567">10</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">itemCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Check correctness of each user key,email and points value, check default sort order and default orderBy" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT u.userKey, u.email, SUM(delta) as suma FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; GROUP by userId order by suma DESC;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">userKey,userEmail,pointsValue</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: of each user key,email and points value" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">for(int i=1;i&lt;=(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-1);i++){

	//same values are ordered in different way by api and jmeter queries that wy we do not process them
     if(vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i+1))) || vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i-1)))){
     	print(&quot;continue - &quot; +i);
     	continue;
     }else {     	
		print(vars.get(&quot;userKey_&quot;+i) + &quot;  -  &quot; + i);
		print(vars.get(&quot;key_&quot;+i) + &quot;  -  &quot; + i);
     }

	if(   vars.get(&quot;userKey_&quot;+i).equals(vars.get(&quot;key_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user keys on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;key_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;userKey_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;userEmail_&quot;+i).equals(vars.get(&quot;email_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user emails on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;userEmail_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;email_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;pointsValue_&quot;+i).equals(vars.get(&quot;value_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user points values on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;pointsValue_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;value_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${newPeriodStartDate}&apos; AND &apos;${periodStartDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - user, limit changed" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed - groupBy - user, limit changed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">user</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="limit" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${limit}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">limit</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="102976443">limit</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="1840632674">
                      <stringProp name="48625">100</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-02-2015 00:00&quot;;
String endDate = &quot;03-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3599307">user</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1178503868">headerDefined</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;userKey&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: email" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">email</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;email&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: totalCount set to 100" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="48625">100</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">itemCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString())  )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Check correctness of each user key,email and points value, check default sort order and default orderBy" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT u.userKey, u.email, SUM(delta) as suma FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; GROUP by userId order by suma DESC;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">userKey,userEmail,pointsValue</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: of each user key,email and points value" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">for(int i=1;i&lt;=(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-1);i++){

	//same values are ordered in different way by api and jmeter queries that wy we do not process them
     if(vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i+1))) || vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i-1)))){
     	print(&quot;continue - &quot; +i);
     	continue;
     }else {     	
		print(vars.get(&quot;userKey_&quot;+i) + &quot;  -  &quot; + i);
		print(vars.get(&quot;key_&quot;+i) + &quot;  -  &quot; + i);
     }
	
	if(   vars.get(&quot;userKey_&quot;+i).equals(vars.get(&quot;key_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user keys on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;key_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;userKey_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;userEmail_&quot;+i).equals(vars.get(&quot;email_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user emails on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;userEmail_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;email_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;pointsValue_&quot;+i).equals(vars.get(&quot;value_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user points values on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;pointsValue_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;value_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - user, offset changed" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed - groupBy - user, offset not changed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">user</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="limit" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${limit}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">limit</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="102976443">limit</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="1840632674">
                      <stringProp name="48625">100</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-02-2015 00:00&quot;;
String endDate = &quot;03-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3599307">user</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1178503868">headerDefined</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">nooffsetKey</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;userKey&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: email" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">nooffsetEmail</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;email&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">nooffsetValue</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: totalCount set to 100" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="48625">100</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">itemCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;nooffsetKey_matchNr&quot;))).toString())  )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;nooffsetKey_matchNr&quot;))).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
              </hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed - groupBy - user, offset changed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">user</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="offset" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${offsett}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">offset</stringProp>
                    </elementProp>
                    <elementProp name="limit" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${limit}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">limit</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="102976443">limit</stringProp>
                    <stringProp name="-1548407231">offsett</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="1281025972">
                      <stringProp name="48625">100</stringProp>
                      <stringProp name="1598">20</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-02-2015 00:00&quot;;
String endDate = &quot;03-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3599307">user</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1178503868">headerDefined</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;userKey&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: email" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">email</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;email&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: totalCount set to 100" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="48625">100</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">itemCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString())  )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Check correctness of each user key,email and points value, check default sort order and default orderBy with set offset" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT u.userKey, u.email, SUM(delta) as suma FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; GROUP by userId order by suma DESC;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">userKey,userEmail,pointsValue</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: of each user key,email and points value" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">for(int i=1;i&lt;=(Integer.parseInt(vars.get(&quot;nooffsetKey_matchNr&quot;))-${offsett}-1);i++){

	//same values are ordered in different way by api and jmeter queries that wy we do not process them
	print(&quot;zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz&quot;);
     if(vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i+1))) || vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i-1)))){
     	print(&quot;continue - &quot; +i);
     	continue;
     }else {     	
		print(vars.get(&quot;key_&quot;+i) + &quot;  -  &quot; + i);
		print(vars.get(&quot;nooffsetKey_&quot;+(i+${offsett})) + &quot;  -  &quot; +i+ &quot;, ofset &quot;+${offsett});
     }
	
	if(   vars.get(&quot;key_&quot;+i).equals(vars.get(&quot;nooffsetKey_&quot;+(i+${offsett})))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user keys on position &quot;+i+&quot; with offset, api with offset - &quot;+vars.get(&quot;key_&quot;+i)+&quot;, api without offset - &quot;+vars.get(&quot;nooffsetKey_&quot;+(i+${offsett}));
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	if(   vars.get(&quot;email_&quot;+i).equals(vars.get(&quot;nooffsetEmail_&quot;+(i+${offsett})))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user emails on position &quot;+i+&quot; with offset, api with offset - &quot;+vars.get(&quot;email_&quot;+i)+&quot;, api without ofset - &quot;+vars.get(&quot;nooffsetEmail_&quot;+(i+${offsett}));
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;nooffsetValue_&quot;+(i+${offsett})))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user points values on position &quot;+i+&quot; with offset, api with offsett - &quot;+vars.get(&quot;value_&quot;+i)+&quot;, api without offset - &quot;+vars.get(&quot;nooffsetValue_&quot;+(i+${offsett}));
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - user, sortField - points orderBy - asc" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed - groupBy - user, offset not changed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">user</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="limit" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${limit}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">limit</stringProp>
                    </elementProp>
                    <elementProp name="sortField" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${sortField}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">sortField</stringProp>
                    </elementProp>
                    <elementProp name="orderBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${orderBy}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">orderBy</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="102976443">limit</stringProp>
                    <stringProp name="-35353092">sortField</stringProp>
                    <stringProp name="-1207110587">orderBy</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="-658686892">
                      <stringProp name="48625">100</stringProp>
                      <stringProp name="-982754077">points</stringProp>
                      <stringProp name="96881">asc</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-02-2015 00:00&quot;;
String endDate = &quot;03-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3599307">user</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1178503868">headerDefined</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;userKey&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: email" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">email</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;email&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: totalCount set to 100" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="48625">100</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">itemCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString())  )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Check correctness of each user key,email and points value, check default sort order and default orderBy" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT u.userKey, u.email, SUM(delta) as suma FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; GROUP by userId order by suma ASC;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">userKey,userEmail,pointsValue</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: of each user key,email and points value" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">for(int i=1;i&lt;=(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-1);i++){

	//same values are ordered in different way by api and jmeter queries that wy we do not process them
     if(vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i+1))) || vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i-1)))){
     	print(&quot;continue - &quot; +i);
     	continue;
     }else {     	
		print(vars.get(&quot;userKey_&quot;+i) + &quot;  -  &quot; + i);
		print(vars.get(&quot;key_&quot;+i) + &quot;  -  &quot; + i);
     }
	
	if(   vars.get(&quot;userKey_&quot;+i).equals(vars.get(&quot;key_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user keys on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;key_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;userKey_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;userEmail_&quot;+i).equals(vars.get(&quot;email_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user emails on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;userEmail_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;email_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;pointsValue_&quot;+i).equals(vars.get(&quot;value_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user points values on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;pointsValue_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;value_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	//sort order
	if(   Integer.parseInt(vars.get(&quot;value_&quot;+i)) &lt;= Integer.parseInt(vars.get(&quot;value_&quot;+(i+1)))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong elements order, should be points ascending. Value i - &quot;+vars.get(&quot;value_&quot;+i)+&quot;, value i+1 - &quot;+vars.get(&quot;value_&quot;+(i+1));
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - user, sortField - points orderBy - desc" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed - groupBy - user, offset not changed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">user</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="limit" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${limit}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">limit</stringProp>
                    </elementProp>
                    <elementProp name="sortField" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${sortField}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">sortField</stringProp>
                    </elementProp>
                    <elementProp name="orderBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${orderBy}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">orderBy</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="102976443">limit</stringProp>
                    <stringProp name="-35353092">sortField</stringProp>
                    <stringProp name="-1207110587">orderBy</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="1629954631">
                      <stringProp name="48625">100</stringProp>
                      <stringProp name="-982754077">points</stringProp>
                      <stringProp name="3079825">desc</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-02-2015 00:00&quot;;
String endDate = &quot;03-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3599307">user</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1178503868">headerDefined</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;userKey&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: email" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">email</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;email&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: totalCount set to 100" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="48625">100</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">itemCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString())  )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Check correctness of each user key,email and points value, check default sort order and default orderBy" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT u.userKey, u.email, SUM(delta) as suma FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; GROUP by userId order by suma DESC;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">userKey,userEmail,pointsValue</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: of each user key,email and points value" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">for(int i=1;i&lt;=(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-1);i++){

	//same values are ordered in different way by api and jmeter queries that wy we do not process them
     if(vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i+1))) || vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i-1)))){
     	print(&quot;continue - &quot; +i);
     	continue;
     }else {     	
		print(vars.get(&quot;userKey_&quot;+i) + &quot;  -  &quot; + i);
		print(vars.get(&quot;key_&quot;+i) + &quot;  -  &quot; + i);
     }
	
	if(   vars.get(&quot;userKey_&quot;+i).equals(vars.get(&quot;key_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user keys on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;key_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;userKey_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;userEmail_&quot;+i).equals(vars.get(&quot;email_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user emails on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;userEmail_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;email_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;pointsValue_&quot;+i).equals(vars.get(&quot;value_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user points values on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;pointsValue_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;value_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	//sort order
	if(   Integer.parseInt(vars.get(&quot;value_&quot;+i)) &gt;= Integer.parseInt(vars.get(&quot;value_&quot;+(i+1)))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong elements order, should be points descending. Value i - &quot;+vars.get(&quot;value_&quot;+i)+&quot;, value i+1 - &quot;+vars.get(&quot;value_&quot;+(i+1));
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="groupBy - user, sortField - value orderBy - asc" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed - groupBy - user, offset not changed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">user</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                    <elementProp name="limit" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${limit}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">limit</stringProp>
                    </elementProp>
                    <elementProp name="sortField" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${sortField}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">sortField</stringProp>
                    </elementProp>
                    <elementProp name="orderBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">${orderBy}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">orderBy</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="true">
                  <collectionProp name="UserParameters.names">
                    <stringProp name="102976443">limit</stringProp>
                    <stringProp name="-35353092">sortField</stringProp>
                    <stringProp name="-1207110587">orderBy</stringProp>
                  </collectionProp>
                  <collectionProp name="UserParameters.thread_values">
                    <collectionProp name="-207601470">
                      <stringProp name="48625">100</stringProp>
                      <stringProp name="3373707">name</stringProp>
                      <stringProp name="96881">asc</stringProp>
                    </collectionProp>
                  </collectionProp>
                  <boolProp name="UserParameters.per_iteration">false</boolProp>
                </UserParameters>
                <hashTree/>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-02-2015 00:00&quot;;
String endDate = &quot;03-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="49586">200</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2524">OK</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticId</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-428932363">points-confirmed</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticId</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="865388756">Confirmed points details views</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">statisticLabel</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">totalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">from</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">to</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
                  <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="3599307">user</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">groupedBy</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">domainType</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="1178503868">headerDefined</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">domainType</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">key</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;userKey&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: email" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">email</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;email&quot;:&quot;(.*?)&quot;,</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">-1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
                  <stringProp name="VAR">value</stringProp>
                  <stringProp name="JSONPATH">$.items[*].value</stringProp>
                  <stringProp name="DEFAULT">null</stringProp>
                  <stringProp name="VARIABLE"></stringProp>
                  <stringProp name="SUBJECT">BODY</stringProp>
                </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                  <stringProp name="RegexExtractor.refname">itemCount</stringProp>
                  <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number">1</stringProp>
                  <stringProp name="Sample.scope">all</stringProp>
                  <stringProp name="Scope.variable">solr_deal</stringProp>
                </RegexExtractor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: totalCount set to 100" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="48625">100</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Assertion.scope">variable</stringProp>
                  <stringProp name="Scope.variable">itemCount</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString())  )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
                <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Check correctness of each user key,email and points value, check default sort order and default orderBy" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT u.userKey, u.email, SUM(delta) as suma FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos; GROUP by userId order by email ASC;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">userKey,userEmail,pointsValue</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: of each user key,email and points value" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">for(int i=1;i&lt;=(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))-1);i++){

	//same values are ordered in different way by api and jmeter queries that wy we do not process them
     if(vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i+1))) || vars.get(&quot;value_&quot;+i).equals(vars.get(&quot;value_&quot;+(i-1))) ){
     	print(&quot;continue - &quot; +i);
     	continue;
     }else {     	
		print(vars.get(&quot;userKey_&quot;+i) + &quot;  -  &quot; + i);
		print(vars.get(&quot;key_&quot;+i) + &quot;  -  &quot; + i);
     }
	
	if(   vars.get(&quot;userKey_&quot;+i).equals(vars.get(&quot;key_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user keys on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;key_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;userKey_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;userEmail_&quot;+i).equals(vars.get(&quot;email_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user emails on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;userEmail_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;email_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
	if(   vars.get(&quot;pointsValue_&quot;+i).equals(vars.get(&quot;value_&quot;+i))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong user points values on position &quot;+i+&quot;, api - &quot;+vars.get(&quot;pointsValue_&quot;+i)+&quot;, database - &quot;+vars.get(&quot;value_&quot;+i);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}

	//sort order
	if(   vars.get(&quot;email_&quot;+i).charAt(0).toLowerCase().compareTo(vars.get(&quot;email_&quot;+(i+1)).charAt(0).toLowerCase()) &lt;=0   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Wrong elements order, should be email ascending. Value i - &quot;+vars.get(&quot;value_&quot;+i)+&quot;, value i+1 - &quot;+vars.get(&quot;value_&quot;+(i+1));
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
	
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get totalCount from MySQL and check if it is correct  - groupBy hour" enabled="true">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">totalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;totalCountDB_1&quot;) == null){
	if(   vars.get(&quot;totalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for totalCount, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;totalCount&quot;).equals(vars.get(&quot;totalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Total Count for selected period &quot;+vars.get(&quot;periodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodEndDate&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;totalCountDB_1&quot;)+&quot;, API result - &quot;+vars.get(&quot;totalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get previoustotalCount from MySQL and check if it is correct  - groupBy hour" enabled="false">
                <stringProp name="dataSource">MySQLPM</stringProp>
                <stringProp name="query">SELECT SUM(delta) FROM points_manager.Points p JOIN points_manager.User u ON u.id = p.userId WHERE p.status in (&apos;CONFIRMED&apos;) AND p.createdAt BETWEEN &apos;${periodStartDateMySQL}&apos; AND &apos;${periodEndDateMySQL}&apos;;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">previousTotalCountDB</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
              </JDBCSampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set begining of previous period" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));


Date tempApiStart = apiFormat.parse(vars.get(&quot;periodStartDate&quot;));
Date tempApiEnd = apiFormat.parse(vars.get(&quot;periodEndDate&quot;));

Long difference = tempApiEnd.getTime() - tempApiStart.getTime();
Long newBeginPeriod = tempApiStart.getTime() - difference; 

Date d = new Date(newBeginPeriod);
String newStartDateMySQLFormat = mySQLFormat.format(d).toString();

vars.put(&quot;newPeriodStartDate&quot;, newStartDateMySQLFormat);</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="-1293956279">${RESPONSE_CODE}</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                  <stringProp name="Scope.variable">json_count_matchNr</stringProp>
                </ResponseAssertion>
                <hashTree/>
                <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
                  <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
                  <stringProp name="BeanShellAssertion.query">if(vars.get(&quot;previousTotalCountDB_1&quot;) == null){
	if(   vars.get(&quot;previousTotalCount&quot;).equals(&quot;0&quot;)   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Database returns null for previous period, api should returns 0 points but returned - &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}else{
	if(   vars.get(&quot;previousTotalCount&quot;).equals(vars.get(&quot;previousTotalCountDB_1&quot;))   )
	{
		Failure = false;
	}else{
		Failure = true;
		FailureMessage = &quot;Previous total Count for selected period &quot;+vars.get(&quot;newPeriodStartDate&quot;)+&quot; - &quot;+vars.get(&quot;periodStartDateMySQL&quot;)+&quot; is wrong, DB result - &quot;+vars.get(&quot;previousTotalCountDB_1&quot;)+&quot; , API result -  &quot;+vars.get(&quot;previousTotalCount&quot;);
		print (FailureMessage);   // this goes to stdout
		log.warn(FailureMessage); // this goes to the JMeter log file
		break;
	}
}</stringProp>
                  <stringProp name="BeanShellAssertion.filename"></stringProp>
                  <stringProp name="BeanShellAssertion.parameters"></stringProp>
                  <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                </BeanShellAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Negative cases" enabled="false"/>
          <hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong groubBy" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong dateRange" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                    <elementProp name="dateRange" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">dateRange</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Wrong previousPeriod" enabled="true"/>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-issued-unsubscribed" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="groupBy" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">hour</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">groupBy</stringProp>
                    </elementProp>
                    <elementProp name="previousPeriod" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">true</boolProp>
                      <stringProp name="Argument.value">wrong</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">previousPeriod</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
                <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
                <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
                <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/statistics/points-issued-unsubscribed</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <boolProp name="HTTPSampler.monitor">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="51508">400</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
                <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
                  <collectionProp name="Asserion.test_strings">
                    <stringProp name="2117236020">Bad Request</stringProp>
                  </collectionProp>
                  <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
                  <boolProp name="Assertion.assume_success">false</boolProp>
                  <intProp name="Assertion.test_type">8</intProp>
                </ResponseAssertion>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="For testing purpose" enabled="false"/>
        <hashTree>
          <ModuleController guiclass="ModuleControllerGui" testclass="ModuleController" testname="Login into dashboard" enabled="true">
            <collectionProp name="ModuleController.node_path">
              <stringProp name="-1227702913">WorkBench</stringProp>
              <stringProp name="764597751">Test Plan</stringProp>
              <stringProp name="-590119856">Epoints reporting API</stringProp>
              <stringProp name="1294809499">preconditions</stringProp>
              <stringProp name="-2013538399">Log in</stringProp>
            </collectionProp>
          </ModuleController>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="points-confirmed - groupBy user" enabled="true">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
              <collectionProp name="Arguments.arguments">
                <elementProp name="groupBy" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">true</boolProp>
                  <stringProp name="Argument.value">user</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">groupBy</stringProp>
                </elementProp>
                <elementProp name="previousPeriod" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">true</boolProp>
                  <stringProp name="Argument.value">true</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">previousPeriod</stringProp>
                </elementProp>
                <elementProp name="dateRange" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">true</boolProp>
                  <stringProp name="Argument.value">${periodRangeDates}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">dateRange</stringProp>
                </elementProp>
                <elementProp name="offset" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">true</boolProp>
                  <stringProp name="Argument.value">6</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">offset</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${HTTP_REQUEST_HOST}</stringProp>
            <stringProp name="HTTPSampler.port">${HTTP_REQUEST_PORT}</stringProp>
            <stringProp name="HTTPSampler.proxyHost">${HTTP_PROXY_HOST}</stringProp>
            <stringProp name="HTTPSampler.proxyPort">${HTTP_PROXY_PORT}</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="HTTPSampler.protocol">http</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/api/statistics/points-confirmed</stringProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <boolProp name="HTTPSampler.monitor">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Set data ranges" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

String startDate = &quot;02-02-2015 00:00&quot;;
String endDate = &quot;03-06-2015 00:00&quot;;

SimpleDateFormat apiFormat  = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm&quot;);
SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
apiFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempApiStart = apiFormat.parse(startDate);
Date tempApiEnd = apiFormat.parse(endDate);
String startDateMySQLFormat = mySQLFormat.format(tempApiStart).toString();
String endDateMySQLFormat = mySQLFormat.format(tempApiEnd).toString();

vars.put(&quot;periodStartDate&quot;, startDate);
vars.put(&quot;periodEndDate&quot;, endDate);
vars.put(&quot;periodRangeDates&quot;, startDate+&quot; +0000,&quot;+endDate+&quot; +0000&quot;);

vars.put(&quot;periodStartDateMySQL&quot;, startDateMySQLFormat);
vars.put(&quot;periodEndDateMySQL&quot;, endDateMySQLFormat);
</stringProp>
            </BeanShellPreProcessor>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response code" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="49586">200</stringProp>
              </collectionProp>
              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">8</intProp>
            </ResponseAssertion>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert: response message" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="2524">OK</stringProp>
              </collectionProp>
              <stringProp name="Assertion.test_field">Assertion.response_message</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">8</intProp>
            </ResponseAssertion>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticId" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">statisticId</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;statisticId&quot;:&quot;(.*?)&quot;,</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticId" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="-428932363">points-confirmed</stringProp>
              </collectionProp>
              <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">8</intProp>
              <stringProp name="Assertion.scope">variable</stringProp>
              <stringProp name="Scope.variable">statisticId</stringProp>
            </ResponseAssertion>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: statisticLabel" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">statisticLabel</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;statisticLabel&quot;:&quot;(.*?)&quot;,</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: statisticLabel" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="865388756">Confirmed points details views</stringProp>
              </collectionProp>
              <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">8</intProp>
              <stringProp name="Assertion.scope">variable</stringProp>
              <stringProp name="Scope.variable">statisticLabel</stringProp>
            </ResponseAssertion>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: totalCount" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">totalCount</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;totalCount&quot;:(.*?),</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: previousTotalCount" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">previousTotalCount</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;previousTotalCount&quot;:(.*?),</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: from" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">from</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;from&quot;:&quot;(.*?)&quot;,</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: from" enabled="true">
              <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealFrom = mySQLFormat.parse(vars.get(&quot;periodStartDateMySQL&quot;));
Date tempApiFrom = apiFormatReturned.parse(vars.get(&quot;from&quot;));

if(mySQLFormat.format(tempRealFrom).toString().equals(mySQLFormat.format(tempApiFrom).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API start date and real start date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
              <stringProp name="BeanShellAssertion.filename"></stringProp>
              <stringProp name="BeanShellAssertion.parameters"></stringProp>
              <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
            </BeanShellAssertion>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: to" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">to</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;to&quot;:&quot;(.*?)&quot;,</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: to " enabled="true">
              <stringProp name="BeanShellAssertion.query">import java.text.SimpleDateFormat;
import java.util.Date; 
import java.util.Locale;
import java.util.Calendar;

SimpleDateFormat mySQLFormat  = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
SimpleDateFormat apiFormatReturned  = new SimpleDateFormat(&quot;yyy-MM-dd&apos;T&apos;HH:mm&quot;);
mySQLFormat.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));
apiFormatReturned.setTimeZone(TimeZone.getTimeZone( &quot;GMT&quot; ));

Date tempRealTo = mySQLFormat.parse(vars.get(&quot;periodEndDateMySQL&quot;));
Date tempApiTo = apiFormatReturned.parse(vars.get(&quot;to&quot;));

if(mySQLFormat.format(tempRealTo).toString().equals(mySQLFormat.format(tempApiTo).toString()))
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Difference between API end date and real end date is greater than one minute&quot;;
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
              <stringProp name="BeanShellAssertion.filename"></stringProp>
              <stringProp name="BeanShellAssertion.parameters"></stringProp>
              <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
            </BeanShellAssertion>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: groupedBy" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">groupedBy</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;groupedBy&quot;:&quot;(.*?)&quot;,</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: groupedBy" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="3599307">user</stringProp>
              </collectionProp>
              <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">8</intProp>
              <stringProp name="Assertion.scope">variable</stringProp>
              <stringProp name="Scope.variable">groupedBy</stringProp>
            </ResponseAssertion>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: domainType" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">domainType</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;domainType&quot;:&quot;(.*?)&quot;,</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: domainType" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="1178503868">headerDefined</stringProp>
              </collectionProp>
              <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">8</intProp>
              <stringProp name="Assertion.scope">variable</stringProp>
              <stringProp name="Scope.variable">domainType</stringProp>
            </ResponseAssertion>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: key" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">key</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;userKey&quot;:&quot;(.*?)&quot;,</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">-1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: email" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">email</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;email&quot;:&quot;(.*?)&quot;,</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">-1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="extract: value" enabled="true">
              <stringProp name="VAR">value</stringProp>
              <stringProp name="JSONPATH">$.items[*].value</stringProp>
              <stringProp name="DEFAULT">null</stringProp>
              <stringProp name="VARIABLE"></stringProp>
              <stringProp name="SUBJECT">BODY</stringProp>
            </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract: itemCount" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">itemCount</stringProp>
              <stringProp name="RegexExtractor.regex">&quot;itemCount&quot;:(.*?),</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">null</stringProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
              <stringProp name="Scope.variable">solr_deal</stringProp>
            </RegexExtractor>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="assert: totalCount default value == 10" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="1567">10</stringProp>
              </collectionProp>
              <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">8</intProp>
              <stringProp name="Assertion.scope">variable</stringProp>
              <stringProp name="Scope.variable">itemCount</stringProp>
            </ResponseAssertion>
            <hashTree/>
            <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="Assert: totalCount from DB and API" enabled="true">
              <stringProp name="TestPlan.comments">compare: id,title,pointsToPurchase, check number of elements: imageURL,brandName,url, for url check also if this is no deeplink</stringProp>
              <stringProp name="BeanShellAssertion.query">if(   vars.get(&quot;itemCount&quot;).equals((Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString())   )
{
	Failure = false;
}else{
	Failure = true;
	FailureMessage = &quot;Items number is incorrect, number of elements - &quot;+(Integer.parseInt(vars.get(&quot;key_matchNr&quot;))).toString()+&quot;, itemCount value - &quot; +vars.get(&quot;itemCount&quot;);
	print (FailureMessage);   // this goes to stdout
	log.warn(FailureMessage); // this goes to the JMeter log file
	break;
}</stringProp>
              <stringProp name="BeanShellAssertion.filename"></stringProp>
              <stringProp name="BeanShellAssertion.parameters"></stringProp>
              <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
            </BeanShellAssertion>
            <hashTree/>
            <com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.gui.JSONFormatterGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonformatter.JSONFormatter" testname="JSON Format Post Processor" enabled="true"/>
            <hashTree/>
          </hashTree>
        </hashTree>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
